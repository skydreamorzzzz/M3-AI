一、文件核心定位
该文件是记录 “约束之间互相冲突” 的统计器，核心作用：
统计每个约束与其他约束的历史冲突次数；
为调度器（scheduler）提供 conflict_risk（冲突风险）数据，辅助约束修复优先级计算。
二、核心功能
一句话总结：记录任意两个约束（A 和 B）的冲突次数，再统计每个约束 “累计冲突总次数”，量化约束的冲突风险。
三、内部核心结构
核心类：ConflictMatrix
该类内部维护 3 个核心变量，通过矩阵实现冲突的结构化统计：
1. index（索引映射）
结构：{constraint_id: 行号}
作用：快速将约束 ID 映射为矩阵的行 / 列索引，便于定位冲突位置。
2. reverse（反向映射）
结构：[constraint_id1, constraint_id2, ...]
作用：是 index 的反向映射，将矩阵行号还原为对应的约束 ID。
3. matrix（对称冲突矩阵）
结构：二维对称矩阵，matrix[i][j] 表示 “约束 i 和约束 j 的冲突次数”；
核心特点：
矩阵对角线值为 0（约束自身不会与自己冲突）；
矩阵对称（matrix[i][j] = matrix[j][i]，冲突是双向的）。
矩阵示例
C1	C2	C3
C1	0	2	1
C2	2	0	3
C3	1	3	0
示例解读：
C1 和 C2 发生过 2 次冲突；
C2 和 C3 发生过 3 次冲突；
C1 和 C3 发生过 1 次冲突。
四、核心方法说明
1. _ensure(cid)
核心作用：确保目标约束 ID 已被纳入矩阵统计范围；
新约束处理逻辑：
为新约束分配唯一的行 / 列索引；
将矩阵维度从 (n, n) 扩展为 (n+1, n+1)；
保留原矩阵所有数据，新增行 / 列初始值为 0；
实现方式：复制旧矩阵并扩展维度，保证历史冲突数据不丢失。
2. record_conflict(a, b)
核心作用：记录一次 “约束 a 和约束 b” 的冲突事件；
执行逻辑：
先调用 _ensure(a) 和 _ensure(b)，确保两个约束都在矩阵中；
matrix[a的索引][b的索引] += 1；
matrix[b的索引][a的索引] += 1（保证矩阵对称）。
3. risk_score(cid)
核心作用：计算单个约束的 “总冲突风险值”；
计算逻辑：返回该约束对应矩阵行的所有数值之和（即该约束与所有其他约束的累计冲突次数）；
示例：C2 的 risk_score = 2（与 C1） + 3（与 C3） = 5。
4. export_dict()
核心作用：将所有约束的冲突风险值导出为字典，供调度器直接使用；
输出格式：
plaintext
{
  "cid1": 总冲突次数1,
  "cid2": 总冲突次数2,
  "cid3": 总冲突次数3,
  ...
}
五、系统中的位置
该模块是调度器的 “冲突风险数据源”，典型调用流程：
Refine loop 中约束发生冲突 → ConflictMatrix.record_conflict (A, B) → 累计冲突次数 → scheduler 调用 risk_score/export_dict () → 降低高冲突风险约束的修复优先级
六、设计特点
动态扩展矩阵：支持新增约束时自动扩展维度，无需提前定义所有约束；
对称统计：冲突双向记录，保证统计结果客观、无遗漏；
完全确定性：相同的冲突记录操作，必然得到相同的统计结果；
低耦合：不依赖图结构、不依赖 LLM，仅做纯数据统计。
七、解决的核心问题
核心目标：避免系统 “反复优先修复易引发冲突的约束”，实现效果：
冲突次数越多的约束 → 冲突风险值越高 → 调度器降低其修复优先级；
冲突次数少的约束 → 冲突风险值越低 → 调度器优先修复；
八、核心总结
该模块是系统的 “历史记忆”，通过统计约束间的历史冲突次数，量化每个约束的冲突风险，让调度器避开 “爱打架” 的约束，优先选择稳定、低副作用的约束进行修复。
