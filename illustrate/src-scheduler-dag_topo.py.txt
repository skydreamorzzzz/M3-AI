一、文件核心定位
该文件是系统的主调度器（Scheduler），核心职责：
基于 DAG（有向无环图）+ 约束结构信息 + 冲突风险，决定 Refine loop 中 “下一步修复哪个约束”；
核心逻辑总结：用依赖顺序做骨架，用结构强度做优先级，用冲突历史做惩罚。
二、核心思想
调度顺序的判定遵循三层优先级规则，层层递进：
第一层：先满足约束间的依赖关系（拓扑排序），保证修复逻辑合理；
第二层：同层级约束用 “结构分数” 做 tie-break（同分排序）；
第三层：对高冲突风险的约束扣减分数，降低其优先级。
三、核心参数：DagTopoParams
参数分为四类，精准控制调度行为，适配不同场景：
1. Tie-break 规则（同层节点排序）
控制拓扑排序中同层级节点的排序方式，默认值：hybrid
参数值	排序规则
none	仅按约束 ID 字典序排序
degree	按约束的出度降序排序
coupling	按约束的耦合度降序排序
hybrid	按 “出度 + 耦合度” 综合分数排序（默认）
2. 结构权重参数
w_out_degree：出度的权重（影响结构分数计算）；
w_coupling_degree：耦合度的权重（影响结构分数计算）。
3. 状态控制参数
聚焦未修复约束，减少无效调度：
failed_only：是否只调度失败的约束；
skip_passed：是否跳过已经通过的约束。
4. 冲突控制参数
引入冲突风险惩罚，规避高副作用约束：
use_conflict_risk：是否启用冲突风险惩罚机制；
alpha_conflict：冲突风险的惩罚权重。
四、核心流程：schedule ()
调度器的核心入口方法，执行以下 6 步标准化逻辑：
步骤 1：保证 DAG 合法性
调用 ensure_dag(graph)，仅修复依赖边（dependency）导致的环，确保图是有向无环图（避免循环依赖）。
步骤 2：拆分边类型
将图中的边拆分为两类，各司其职：
dep_edges：依赖边 → 用于拓扑排序，保证修复顺序；
coup_edges：耦合边 → 仅用于结构分数计算，不影响排序。
步骤 3：筛选候选节点
调用 _select_candidates()，默认只筛选 “未通过的约束” 作为候选修复节点。
步骤 4：构建依赖子图
仅保留候选节点内部的依赖关系，构建调度用核心子图：
adj：邻接表（记录节点间的依赖关系）；
indeg：入度表（记录每个节点的依赖前置节点数）。
步骤 5：计算结构指标
为每个候选节点计算两类核心结构指标（用于后续打分）：
out_degree：出度（被多少下游约束依赖）；
coupling_degree：耦合度（与多少约束软耦合）。
步骤 6：执行 Kahn 拓扑排序
调用 _kahn_topo(...)，生成初步的约束修复顺序。
五、Kahn 拓扑排序核心逻辑
拓扑排序是调度的核心，保证依赖顺序的合理性：
1. 初始化
将所有 “入度（indeg）= 0” 的节点加入初始队列 Q（无前置依赖的节点）。
2. 迭代排序
每一轮执行以下操作：
从队列 Q 中选择 “最优节点”（按 Tie-break 规则）；
将该节点加入最终调度顺序；
更新该节点所有后继节点的入度（indeg -= 1）；
若后继节点入度变为 0，加入队列 Q；
重复直至队列为空。
六、Tie-break 核心规则（_pop_best ()）
同层级节点的 “最优选择” 由分数决定，保证排序完全可复现：
1. 分数计算公式
结构分 = w_out_degree × 出度 + w_coupling_degree × 耦合度
风险惩罚 = alpha_conflict × 冲突风险值
最终分 = 结构分 - 风险惩罚
2. 排序规则
最终分越高 → 优先级越高；
分数相同时 → 按约束 ID 字典序排序（兜底保证确定性）；
全程完全 deterministic（确定性），相同输入必出相同顺序。
七、循环残留处理（异常兜底）
若 DAG 不完整导致部分节点未被拓扑排序覆盖（理论上不应出现），剩余节点按以下优先级补到调度顺序末尾：
出度降序 → 2. 耦合度降序 → 3. 冲突风险升序 → 4. 字典序。
八、解决的核心问题
该调度器从三层维度解决约束修复的调度难题：
1. 依赖顺序问题
按约束依赖关系排序（如先修 OBJECT → 再修 COUNT → 最后修 SPATIAL），避免 “修布局后改数量” 的修复震荡。
2. 结构影响力问题
优先修复 “出度高” 的约束（影响最多下游约束的节点），最大化单次修复的收益。
3. 冲突记忆问题
对历史冲突次数多的约束扣减分数，降低其优先级，减少修复副作用。
九、系统中的位置
调度器是 Refine loop 的 “决策核心”，在 loop_core 中的调用链：
loop_core（主循环）→ scheduler.schedule ()（生成约束修复顺序）→ 选取第一个约束 → checker（检查并修复该约束）
十、核心总结
该调度器是结构优先 + 冲突感知 + 完全可复现的 DAG 调度器，既保证约束修复的逻辑合理性，又通过结构分数和冲突惩罚实现 “智能选修”，最大化修复效率、最小化副作用。